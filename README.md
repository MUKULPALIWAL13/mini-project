# README.md

## Title
Design and Implementation of a 32-bit RISC-V Processor: Single-Cycle Architecture, Floating-Point Extension, Custom Assembler, and Five-Stage Pipelined Processor with FPGA Deployment

---

## 1. Introduction

This project describes the construction of a 32-bit RISC-V processor in two forms:  
a single-cycle architecture with floating-point unit integration and a synthesizable five-stage pipelined processor.  
Both designs were implemented in Verilog, verified using simulation tools, and deployed on FPGA hardware.

A custom Python-based assembler supporting RV32F-like instructions was developed to generate machine codes for the instruction memory.

---

## 2. Architecture Overview

### 2.1 Single-Cycle Architecture  
A complete datapath including ALU, register files, immediate generator, control logic, floating-point datapath, and memory interface.

**Place RTL Diagram Here:**  
*(Paste Single-Cycle Datapath Figure / RTL Block Diagram)*  
<br><br><br><br><br>

### 2.2 Five-Stage Pipelined Architecture  
Pipeline stages: IF, ID, EX, MEM, WB. Includes forwarding logic, hazard detection, flushing mechanisms, and pipeline registers.

**Place Pipelined Datapath RTL Diagram Here:**  
*(Paste Pipeline Datapath / RTL Block Diagram)*  
<br><br><br><br><br>

---

## 3. Performance Analysis

### 3.1 Single-Cycle Execution Time

- Each instruction takes exactly *1 cycle*
- Total cycles:  
  *Cycles_single = N*
- Execution time:  
  *T_single = N × T_clk_single*

The clock period is constrained by the slowest instruction.

### 3.2 Pipelined Execution Time

For *N* instructions:

*Cycles_pipeline_actual = N + (k − 1) + S + F*  
where:

- *k = 5* (pipeline depth)
- *S* = stall cycles
- *F* = flush cycles

### 3.3 CPI Comparison

- Single-cycle CPI = *1.0*
- Pipeline CPI ≈ *1.1 – 1.2*

### 3.4 Speedup

*Speedup = T_single / T_pipeline_actual*

For large *N*, pipeline approaches ideal throughput.

---

## 4. Single-Cycle Processor Verification

### 4.1 Assembly Test Program  
**Paste Assembly Program Here:**  
*(Example test code for ALU, load-store, floating-point operations)*  
<br><br><br><br><br>

### 4.2 Assembler Output  
**Paste Generated Machine Code Here:**  
*(Hex / Binary output generated by Python assembler)*  
<br><br><br><br><br>

### 4.3 GTKWAVE Output (Single Cycle)  
**Paste Waveform Image or Description Here:**  
*(Insert timing diagram showing correct execution sequence)*  
<br><br><br><br><br>

---

## 5. Pipelined Processor Verification

### 5.1 Assembly Test Program  
**Paste Pipeline Test Assembly Program Here:**  
*(Sequence showing hazards, branch instructions, load-use tests)*  
<br><br><br><br><br>

### 5.2 GTKWAVE Output (Pipeline Execution)  
**Paste Pipeline Waveform Here:**  
*(Include forwarding, stall cycles, control flush behavior)*  
<br><br><br><br><br>

### 5.3 FPGA Board Output Verification  
**Paste Board Output / LED Patterns / Photographs Here:**  
*(Show LED-based debug, switch-based memory inspection)*  
<br><br><br><br><br>

---

## 6. FPGA Deployment Details

The pipelined processor was validated on the **Digilent ZedBoard (Zynq-7000 XC7Z020)**.

### Board Specifications

- ~85k logic cells  
- ~560 KB BRAM  
- 100 MHz oscillator  
- USB-JTAG  
- 8 switches, 9 LEDs, pushbuttons

### Notes for Deployment

- Clocking Wizard used for stable clock generation  
- Debounced reset integrated  
- LEDs mapped for execution visualization  
- Switches used for address selection and data inspection  

---

## 7. Conclusion

This repository demonstrates:

- Correct functioning of both single-cycle and pipelined RISC-V processors  
- Full datapath implementation with floating-point capability  
- Hazard management using forwarding, stalls, and flushing  
- Custom assembler integration  
- Full simulation and FPGA validation  

This work combines architectural understanding with practical implementation and hardware testing.

---

## Credits

Project Contributors:  
*Mukul Paliwal*  
*Soham Palkrit*
