# README.md

## Title
Design and Implementation of a 32-bit RISC-V Processor: Single-Cycle Architecture, Floating-Point Extension, Custom Assembler, and Five-Stage Pipelined Processor with FPGA Deployment

---

## 1. Introduction

This project describes the construction of a 32-bit RISC-V processor in two forms:  
a single-cycle architecture with floating-point unit integration and a synthesizable five-stage pipelined processor.  
Both designs were implemented in Verilog, verified using simulation tools, and deployed on FPGA hardware.

A custom Python-based assembler supporting RV32F-like instructions was developed to generate machine codes for the instruction memory.

---

## 2. Architecture Overview

### 2.1 Single-Cycle Architecture  
A complete datapath including ALU, register files, immediate generator, control logic, floating-point datapath, and memory interface.

![](singlecycle_core\docs\architecture.jpeg
)
Architecture for Single cycle  

![](singlecycle_core\docs\FP_RTL.png)
RTL of Floating Point unit 
### 2.2 Five-Stage Pipelined Architecture  
Pipeline stages: IF, ID, EX, MEM, WB. Includes forwarding logic, hazard detection, flushing mechanisms, and pipeline registers.

**Place Pipelined Datapath RTL Diagram Here:**  
*(Paste Pipeline Datapath / RTL Block Diagram)*  
<br>

---

## 3. Performance Analysis

### 3.1 Single-Cycle Execution Time

- Each instruction takes exactly *1 cycle*
- Total cycles:  
  *Cycles_single = N*
- Execution time:  
  *T_single = N × T_clk_single*

The clock period is constrained by the slowest instruction.

### 3.2 Pipelined Execution Time

For *N* instructions:

*Cycles_pipeline_actual = N + (k − 1) + S + F*  
where:

- *k = 5* (pipeline depth)
- *S* = stall cycles
- *F* = flush cycles

### 3.3 CPI Comparison

- Single-cycle CPI = *1.0*
- Pipeline CPI ≈ *1.1 – 1.2*

### 3.4 Speedup

*Speedup = T_single / T_pipeline_actual*

For large *N*, pipeline approaches ideal throughput.

---

## 4. Single-Cycle Processor Verification

### 4.1 Assembly Test Program  
**Paste Assembly Program Here:**  
*(Example test code for ALU, load-store, floating-point operations)*  
<br><br>
```_start:
    addi sp, sp, -8       # reserve 8 bytes on stack
    sw   x0, 4(sp)        # store 0 at (sp+4)
    sw   x0, 0(sp)        # store 0 at (sp)

    addi s1, x0, 0        # s1 = sum = 0
    addi t0, x0, 0        # t0 = counter = 0
    addi t1, x0, 10        # t1 = limit = 10
LOOP:
    slt  t2, t0, t1       # t2 = (t0 < 10)
    beq  t2, x0, END      # if not less → jump to END
    add  s1, s1, t0       # s1 += t0
    addi t0, t0, 1        # t0++
    beq  x0, x0, LOOP     # unconditional jump
END:
    sw   s1, 0(sp)        # store result (sum=45) at 0(sp)
    lw   s0, 0(sp)        # load back sum into s0
    addi sp, sp, 8        # release stack
    beq  x0, x0, END      # hang here
```

### 4.2 Assembler Output  
**Paste Generated Machine Code Here:**  
*(Hex generated by the assembler)
```--- Generated Machine Code (Big-Endian Bytes) ---
0x00: FF 81 01 13
0x04: 00 01 22 23
0x08: 00 01 20 23
0x0C: 00 00 04 93
0x10: 00 00 02 93
0x14: 00 A0 03 13
0x18: 00 62 A3 B3
0x1C: 00 03 88 63
0x20: 00 54 84 B3
0x24: 00 12 82 93
0x28: FE 00 08 E3
0x2C: 00 91 20 23
0x30: 00 01 24 03
0x34: 00 81 01 13
0x38: FE 00 0A E3
```  

### 4.3 GTKWAVE Output (Single Cycle)  
![](singlecycle_core\simulations\single_Cyclefirstten.png
)control siganls
<br>
![ALUout](singlecycle_core\simulations\ALUout.png)
ALUout
<br>
## 5. Pipelined Processor Verification

### 5.1 Assembly Test Program  
**Paste Pipeline Test Assembly Program Here:**  
*(Sequence showing hazards, branch instructions, load-use tests)*  
<br><br><br><br><br>

### 5.2 GTKWAVE Output (Pipeline Execution)  
**Paste Pipeline Waveform Here:**  
*(Include forwarding, stall cycles, control flush behavior)*  
<br><br><br><br><br>

### 5.3 FPGA Board Output Verification  
**Paste Board Output / LED Patterns / Photographs Here:**  
*(Show LED-based debug, switch-based memory inspection)*  
<br><br><br><br><br>

---

## 6. FPGA Deployment Details

The pipelined processor was validated on the **Digilent ZedBoard (Zynq-7000 XC7Z020)**.

### Board Specifications

- ~85k logic cells  
- ~560 KB BRAM  
- 100 MHz oscillator  
- USB-JTAG  
- 8 switches, 9 LEDs, pushbuttons

### Notes for Deployment

- Clocking Wizard used for stable clock generation  
- Debounced reset integrated  
- LEDs mapped for execution visualization  
- Switches used for address selection and data inspection  

---

## 7. Conclusion

This repository demonstrates:

- Correct functioning of both single-cycle and pipelined RISC-V processors  
- Full datapath implementation with floating-point capability  
- Hazard management using forwarding, stalls, and flushing  
- Custom assembler integration  
- Full simulation and FPGA validation  

This work combines architectural understanding with practical implementation and hardware testing.

---

## Credits

Project Contributors:  
*Mukul Paliwal*  
*Soham Palkrit*
